/*  ML Label Images
 *
 *  From: https://github.com/PokemonAutomation/
 *
 */

#ifndef PokemonAutomation_ML_LabelImages_H
#define PokemonAutomation_ML_LabelImages_H

#include "Common/Cpp/Options/BatchOption.h"
#include "Common/Cpp/Options/FloatingPointOption.h"
#include "CommonFramework/Panels/PanelInstance.h"
#include "CommonFramework/Panels/UI/PanelWidget.h"
#include "CommonFramework/ImageTypes/ImageViewRGB32.h"
#include "CommonFramework/ImageTypes/ImageRGB32.h"
#include "CommonFramework/VideoPipeline/VideoOverlayTypes.h"
#include "Pokemon/Options/Pokemon_HomeSpriteSelectOption.h"
#include "NintendoSwitch/Framework/NintendoSwitch_SwitchSystemOption.h"
#include "NintendoSwitch/Framework/NintendoSwitch_SwitchSystemSession.h"
#include "CommonFramework/VideoPipeline/VideoOverlayScopes.h"
#include <QGraphicsScene>
#include "ML/DataLabeling/SegmentAnythingModel.h"
#include "ML/UI/ML_ImageDisplayOption.h"
#include "ML/UI/ML_ImageDisplaySession.h"

class QGraphicsView;
class QGraphicsPixmapItem;

namespace PokemonAutomation{


class ConfigWidget;


namespace ML{


class ImageDisplayWidget;
class LabelImages_Widget;


// Store annotation generated by user and ML model on one object
// also include the related overlay rendering.
// Since it owns rendering objects and the rendering framework needs
// the address of the rendering objects to keep track of them,
// never copy or move these ObjectAnnotation objects after rendering code has
// access to them!
struct ObjectAnnotation{
    ImagePixelBox user_box; // user drawn loose bounding box
    ImagePixelBox mask_box;
    std::vector<bool> mask;
    std::string label = "unknown";

    ObjectAnnotation();
};


class LabelImages_Descriptor : public PanelDescriptor{
public:
    LabelImages_Descriptor();
};

// label image program
class LabelImages : public PanelInstance{
public:
    LabelImages(const LabelImages_Descriptor& descriptor);
    virtual QWidget* make_widget(QWidget& parent, PanelHolder& holder) override;

public:
    //  Serialization
    virtual void from_json(const JsonValue& json) override;
    virtual JsonValue to_json() const override;

    void load_image_related_data(const std::string& image_path, const size_t source_image_width, const size_t source_image_height);

    void update_rendered_objects(VideoOverlaySet& overlayset);

    void compute_mask(VideoOverlaySet& overlay_set);

private:
    friend class LabelImages_Widget;
    friend class DrawnBoundingBox;
    // image display options like what image file is loaded
    ImageDisplayOption m_switch_control_option;
    // the group option that holds rest of the options defined below:
    BatchOption m_options;

    FloatingPointOption X;
    FloatingPointOption Y;
    FloatingPointOption WIDTH;
    FloatingPointOption HEIGHT;
    Pokemon::HomeSpriteSelectCell FORM_LABEL;

    size_t source_image_height = 0;
    size_t source_image_width = 0;
    std::vector<float> m_image_embedding;
    std::vector<bool> m_output_boolean_mask;

    // buffer to compute SAM mask on
    ImageRGB32 m_mask_image;

    SAMSession m_sam_session;
    std::vector<ObjectAnnotation> m_annotations;
    size_t m_last_object_idx = 0;
    std::string m_annotation_file_path;
    // if we find an annotation file that is supposed to be created by user in a previous session, but
    // we fail to load it, then we shouldn't overwrite this file to possibly erase the previous work.
    // so this flag is used to denote if we fail to load an annotation file
    bool m_fail_to_load_annotation_file = false;
};


class DrawnBoundingBox : public ConfigOption::Listener, public VideoOverlay::MouseListener{
public:
    ~DrawnBoundingBox();
    DrawnBoundingBox(LabelImages_Widget& widget, VideoOverlay& overlay);
    virtual void on_config_value_changed(void* object) override;
    virtual void on_mouse_press(double x, double y) override;
    virtual void on_mouse_release(double x, double y) override;
    virtual void on_mouse_move(double x, double y) override;

private:
    void detach();

private:
    LabelImages_Widget& m_widget;
    VideoOverlay& m_overlay;
    std::mutex m_lock;

    std::optional<std::pair<double, double>> m_mouse_start;
};


class LabelImages_Widget : public PanelWidget, public ConfigOption::Listener{
public:
    ~LabelImages_Widget();
    LabelImages_Widget(
        QWidget& parent,
        LabelImages& instance,
        PanelHolder& holder
    );

    virtual void on_config_value_changed(void* object) override;

private:
    LabelImages& m_program;
    ImageDisplaySession m_session;
    ImageDisplayWidget* m_switch_widget;
    VideoOverlaySet m_overlay_set;
    DrawnBoundingBox m_drawn_box;
    ConfigWidget* m_option_widget;

    friend class DrawnBoundingBox;
};




}
}
#endif

